[{"content":" Linux 명령어 정리 파일 관련 명령어 빈 파일 생성 1 touch [ 파일명 ] 파일 삭제 1 rm [ 파일명 ] 파일 복사 1 cp [파일경로 및 파일이름] [원하는 경로 및 파일이름] 파일 이동 (이름 변경시에도 사용) 1 2 mv [파일경로 및 파일이름] [원하는 경로 및 파일이름] mv [원래 파일 이름] [원하는 파일 이름] 파일 생성 및 기존 파일 수정(nano Editor) 1 nano [파일명] 파일 내용 보기 1 cat [파일명] 파일 위치 검색 1 2 3 4 locate *.[확장자명] : [확장자명]을 가진 파일 찾기 - 디렉토리가 아닌 데이터베이스에서 찾는다. find . *.[확장자명] : [확장자명]을 가진 파일 찾기 - 디렉토리에서 찾는다. whereis ls : 실행파일 위치 찾기 whereis rm : 실행파일 위치 찾기 현재 경로 확인 1 pwd 명령창 내용 삭제 1 clear 명령어 도움말 확인 1 2 [명령어] --help man [명령어] :/[찾고싶은단어] 까지 옵션을 사용해서 특정 단어 찾기 가능, 그 상태를 유지한 상태로 n을 누르면 n이 들어간 단어 찾기 실행 패키지 매니저 패키지 목록 업데이트 1 apt-get update 패키지 찾기 1 apt-cache search [패키지명] 패키지 설치 1 apt-get install [패키지명] 패키지 업그레이드 1 2 apt-get upgrade : 패키지 목록에 있는 모든 패키지 업데이트 apt-get upgrade [패키지명] : 특정 [패키지명]만 업데이트 패키지 삭제 1 apt-get remove [패키지명] : 특정 [패키지명] 삭제 다운로드 파일 다운로드 (wget 사용) 1 wget -0 [저장할 파일명] [다운로드 url] ","date":"2022-07-20T00:00:00Z","permalink":"https://jeonjongyook.github.io/post/start-linux3/","title":"Linux공부 제 3장"},{"content":" Linux(Ubuntu) 공식 홈페이지 접속 부팅 시 필요한 USB 준비(16GB이상) 빠른 포맷으로 포맷\n우분투 사이트에서 설치용 iso 파일을 다운로드 사이트 URL\n2022년 7월 19일 기준\n다운로드 파일 정보 : 3.4G\nUSB installer를 다운로드한 후 설치 파일을 실행 사이트 URL 리눅스 설치할 디스크 드라이브 구성 및 용량 할당 제어판으로 가서 시스템 및 보안 - 관리 도구 하드 디스크 파티션 만들기 및 포맷을 클릭 용도에 따라서 다를 수 있겠지만 해당 OS를 전문적인 서버용으로 사용할 생각이 없다면 기존 C드라이브에 할당된 60기가 정도를 할당하여 리눅스용 디스크로 사용해도 무방함 (최소 요구사항은 만족) 기존 C드라이브를 선택 후 마우스 오른쪽을 클릭하면 볼륨 축소 메뉴 클릭 축소할 공간 입력 란에 60GB(60000) 입력 Window OS 종료 설정 및 BIOS 설정 에서 Secure Boot 옵션 변경하기 제어판 \u0026gt; 하드웨어 및 소리 \u0026gt; 전원 옵션 \u0026gt; 시스템 설정 빠른 시작 켜기 해제 (OFF) Window 다시 시작 후 F2 연타 ( PC별로 다를 수 있음 ) Security -\u0026gt; Secure Boot Configuration Secure Boot Option 을 Disabled로 변경 재시작 후 BIOS 메뉴에서 부팅 우선순위 바꾸기 BIOS 메뉴에서 리눅스 OS 설치용 USB가 우선순위 1로 되도록 우선순위 변경 후 저장 Install Ubuntu 클릭 및 언어 선택란에 한국어 클릭 참고링크\n","date":"2022-07-19T00:00:00Z","permalink":"https://jeonjongyook.github.io/post/start-linux2/","title":"Linux공부 제 2장"},{"content":" Linux 리눅스(Linux)는 컴퓨터 운영체제의 한 종류이자, 커널 자체를 의미합니다.\n특징 소스 코드가 공개되어있는 ‘자유 소프트웨어’와 ‘오픈 소스 개발’의 가장 유명한 표본 다중 사용자, 다중 작업(멀티 태스킹), 다중 스레드를 지원하는 네트워크 운영 체제(NOS)로, 여러 사람이 하나의 리눅스 시스템에 접속하여 다수의 프로그램을 동시에 실행할 수 있다. 사용 가능한 개발 언어와 Database Language\nC++ Java Perl PHP Python Ruby Lua Go DataBase - DBMS\nOracle MySQL MariaDB PostgresSQL CUBRID Firebird ","date":"2022-07-12T00:00:00Z","permalink":"https://jeonjongyook.github.io/post/start-linux/","title":"Linux공부 제 1장"},{"content":" 클린코드란 무엇인가? -\u0026gt; 읽기 쉬운 코드가 클린코드이다.\nC++의 창시자인 Bjarne Stroustrup은 클린코드를 다음과 같이 정의하였다.\n코드가 우아하다는 의미는 군더더기 없이 깔끔하다는 의미이고,\n효과적이라는 것은 기능을 수행하는 코드를 최대한 작은 라인으로 구현한다.\n이처럼 클린코드는 프로그래머가 기한을 맞추기 위해 양산하는 나쁜 코드가 아니라 코드를 최대한 깨끗하게 유지하여 사람도 읽기 쉽고 고치기도 쉬운 그런 코드를 말하게 된다.\n","date":"2022-07-12T00:00:00Z","permalink":"https://jeonjongyook.github.io/post/cleancode/","title":"클린코드 제 1장"},{"content":"개발 블로그를 어떻게 시작하게 되었는가? 나는 나 자신에게 질문하는 것을 좋아한다.\n그로 인해 평소에도 종종 비록 나에게 시덥지도 않은 질문일지라도 스스로 에게 묻는다.\n\u0026ldquo;내가 하고 있는 이 행동들이 과연 현재와 미래의 나에게 도움이 될까?\u0026rdquo;\n\u0026ldquo;취업이 먼저인가? 대학이 먼저인가?\u0026rdquo;\n\u0026ldquo;자격증이 먼저인가? 하나라도 무언갈 만들어 실력을 키우는 것이 좋을까?\u0026rdquo;\n\u0026ldquo;내가 정말 잘 하고 있는것인가? 아니라면 왜 아닌가?\u0026rdquo;\n\u0026hellip; \u0026hellip; \u0026hellip;\n등등 위와같은 질문들을 포함해서 그때그때 생각나는 질문을 나 자신에게 묻는다.\n바로 질문에 대답을 할 수는 없다.\n하지만 시간이 지나갈 수록 그 질문에 관한 답변을 해 나아가는 것이 내 목표이다.\n앞으로의 목표와 계획은? 계속 이 블로그를 운영하고 게시글을 작성하는 사람으로서,\n또한 한명의 개발자로서 더욱더 성장할 수 있는 계기가 될 수 있도록 할 것이고,\n내용들을 더 추가해 나아가면서 내 Tech Stack에 기여를 할 수 있도록 할 것이다.\n","date":"2022-06-29T00:00:00Z","permalink":"https://jeonjongyook.github.io/post/start-devblog/","title":"개발블로그의 시작"},{"content":"1학년 1학년때의 이야기 이제 고등학교라는 곳에 처음 들어와 어딘지 잘 모르고 헤맸던 시기, 취업이 뭔지, 자격증이 뭔지, 방과후에 MDP까지 너무 힘들다고 생각했다. 개발 공부의 초기라 아무것도 몰랐던 시기이다.\n2학년 2학년때의 이야기 불과 고등학교에 들어온지 벌써 1년이 넘는 시간이 흐른 2021년, 나는 어느새 많이 성장했고, 코드를 보는 능력, 코드를 작성하는 능력까지 실력이 많이 늘었다고 생각한다. 이쯤되면 난 정말 잘한다고 생각하는 어깨의 뽕(?)이 들어간 시기이다.\n3학년 3학년때의 이야기 이제 어엿한 고등학교 3학년 학생이자, 취업 준비생 이기도 하다. 정말 1학년의 아무것도 모르던 과거의 나와 비교해 3학년의 나는 정말 많이 성장했다. 내 주변의 사람들이 없었다면 지금까지의 나는 정말 상상도 못할 사람이 되었다.\n","date":"2022-06-29T00:00:00Z","permalink":"https://jeonjongyook.github.io/post/school-life/","title":"고등학교 생활의 시작"},{"content":"자율전공동아리란? 지금까지 자신이 배운 전공실력을 맘껏 발휘하고 평소에 자신이 제작(창작)하고 싶어했던 프로젝트나 개발서비스 등을 맘껏 기획하여\n처음부터 끝까지 스스로 공부하며 개발해보며 본인도 성장하고 자습시간을 활용하여 남을 가르쳐줌으로써 뿌듯함, 전공 및 개발 실력을 동시에 느낄 수 있는 일석이조의 대명사.\n2021년을 시작으로 현재 2022년에는 웹개발 자율전공동아리, WWW를 기획하고 운영하며 학교를 졸업한 선배님들을 대상으로 강사를 초청하여\n평소에는 배우지 못했던 직접 현장의 근무하는 실무(개발)자의 조언도 같이 들으며 취업 준비에도 도움이 되는 아주 유용한 동아리 이다.\n그래서 현재는? 현재는 웹개발 자율전공동아리 회장으로써 강사(졸업하신 선배님)분들을 초청하여 2학년 후배들과 같은 학년인 친구들에게 열심히 수업을 하며 가르쳐 주고 있다.\n앞으로 추진 방향성? 웹개발 자율전공동아리 이름 그대로 자유롭고 전공적으로 많은 것을 배우고 경험할 수 있는 동아리가 될 수 있도록 후배들에게 많은 것을 가르쳐주고 떠날예정이다(?).\n느낀점 고등학교에서 자율전공동아리를 처음 계획하고 만들어가기 시작한 나로서는, 학교에서 있었던 3년중 가장 뿌듯한 일중의 하나가 아닐까 싶다.\n하면서 힘든일도 엄청 많았지만 그런 힘든일들을 차분히 해결해 나아가다 보니 자연스레 벌써 취업할 시간이 되어 버려 시간이 조금만 더 있었으면 어떨까 싶다.\n","date":"2022-06-29T00:00:00Z","image":"https://jeonjongyook.github.io/post/start-club-admin/cover_huf096cf9a1c12907f11dc97b5d723927f_116327_120x120_fill_box_smart1_3.png","permalink":"https://jeonjongyook.github.io/post/start-club-admin/","title":"웹개발 자율 전공 동아리의 시작"},{"content":"취업 준비의 첫 발판 취업준비라고 하면 나는 정말 쉬울 것이라 생각했지만 절대 그것이 아니였다. 절대.\n학생의 신분으로 학교에 소속되어 학교에서 모든 일들을 대신해주니 나는 정말 편했었다. 이 편함이 언제까지일 지는 모르지만 말이다.\n자기소개서 포트폴리오 면접 이 세가지가 평범한 취업 준비인데, 나는 위 3가지중 면접이라고 생각한다.\n어쩌면 나라는 사람을 다른 삶을 살아온 사람들에게 보여주는 기회라고 생각한다.\n면접에서 가장 중요한 것은 앞에 면접관으로 나온 사람들에게 절대 내가 긴장했다는 것을 보여주지 말아야 한다.\n","date":"2022-06-29T00:00:00Z","permalink":"https://jeonjongyook.github.io/post/job-preparation/","title":"프론트엔드 주니어 개발자로서 준비해야할 사항들"},{"content":" Component Registration vue component 를 global component로 만들기\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import Vue from \u0026#39;vue\u0026#39; import upperFirst from \u0026#39;lodash/upperFirst\u0026#39; import camelCase from \u0026#39;lodash/camelCase\u0026#39; const requireComponent = require.context( \u0026#39;.\u0026#39;, false, /base-[\\w-].vue$/ ) requireComponent.keys().forEach(fileName =\u0026gt; { // Get component config const componentConfig = requireComponent(fileName) // Get PascalCase name of component const componentName = upperFirst( camelCase(fileName.replace(/^\\.\\//, \u0026#39;\u0026#39;).replace(/\\.\\w+$/, \u0026#39;\u0026#39;)) ) // Register component globally Vue.component(componentName, componentConfig.default || componentConfig) }) Module Registration vuex module 등록\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import camelCase from \u0026#39;lodash/camelCase\u0026#39; const requireModule = require.context(\u0026#39;.\u0026#39;, false, /\\.js$/) const modules = {} requireModule.keys().forEach(fileName =\u0026gt; { // Don\u0026#39;t register ths file as a vuex module if (fileName === \u0026#39;./index.js\u0026#39;) return const moduleName = camelCase(fileName.replace(/(\\.\\/|\\.js)/, \u0026#39;\u0026#39;)) modules[moduleName] = { namespaced: true, ...requireModule(fileName) } }) export default modules Single-Root Components template 안에 root element가 하나 있어야 한다. 하지만 이것이 불필요하게 느껴질 경우에 functional component를 이용해서 처리하는 방법이 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;NavBarRoutes :routes=\u0026#34;persistentNavRoutes\u0026#34;/\u0026gt; \u0026lt;NavBarRoutes v-if=\u0026#34;logedIn\u0026#34; :routes=\u0026#34;persistentNavRoutes\u0026#34; /\u0026gt; \u0026lt;NavBarRoutes v-else :routes=\u0026#34;persistentNavRoutes\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; [NavBarRoutes component] export default { functional: true, render(h, {props}) { return props.routes.map(route =\u0026gt; \u0026lt;li key={route.name}\u0026gt; \u0026lt;router-link to={route}\u0026gt; {route.title} \u0026lt;/route-link\u0026gt; \u0026lt;/li\u0026gt; ) } } Transparent Wrappers inheritAttrs, vm.$attrs, vm.$listeners를 이용하면 wrapper component를 쉽게 만들 수 있다.\n@focus 부분에 .native를 붙이면 자식 컴포넌트에서 vm.$listeners 로 전달 받지 못하기 때문에 붙이면 안된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;BaseInput placeholder=\u0026#34;Waht\u0026#39;s your name?\u0026#34; @focus=\u0026#34;doSomething\u0026#34; /\u0026gt; [BaseInput component] \u0026lt;template\u0026gt; \u0026lt;label\u0026gt; {{ label }} \u0026lt;input V-bind=\u0026#34;$attrs\u0026#34; :value=\u0026#34;value\u0026#34; v-on=\u0026#34;listeners\u0026#34; \u0026gt;\u0026lt;/input\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { inheritAttrs: false, computed: { listeners() { return { ...this.$listeners input:event =\u0026gt; this.$emit(\u0026#39;input\u0026#39;, event.target.value) } } } } \u0026lt;/script\u0026gt; 참고 영상 : https://youtu.be/7lpemgMhi0k?t=2\n","date":"2022-02-10T00:00:00Z","permalink":"https://jeonjongyook.github.io/post/start-vue/","title":"Vue.js"},{"content":"Q : 개발을 어쩌다가 하게 되셨나요? 고등학교 친구들끼리 모여 SNS를 만들겠다고 서로 아무것도 모르고 시작한 프로젝트 입니다. 하지만 앞으로 꾸준히 업데이트 할 예정이니 지켜봐 주세요!\nQ : vue.js라는 언어를 굳이 사용하신 이유가 뭘까요? 우선 FE쪽에서 vue와 react, Angular 등의 다양한 선택지가 있었지만 vue.js의 이름부터 딱 끌렸고, 도전정신과 공부하는 자세로 임해보자라는 마인드로 언어를 선택하게 되었습니다!\n","date":"2022-02-10T00:00:00Z","permalink":"https://jeonjongyook.github.io/post/start-service/","title":"세미콜론(Semicolon) - 누구나, 다같이"}]